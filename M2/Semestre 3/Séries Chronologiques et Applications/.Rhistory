cat("Test de Ljung-Box : p-val=", lbpv, sep="")
# Histogramme
hist(Res, breaks=sqrt(n), freq=FALSE, col="skyblue", main="Densité", xlab="", ylab="")
curve(dnorm(x, m=m, sd=s), col="red", lty=2, add=TRUE)
# Test de Shapiro-Wilk
swpv = shapiro.test(Res)$p.value
cat("\nTest de Shapiro : p-val=", swpv, sep="")
# QQ plots
qqnorm(Res, main="Quantiles", xlab="", ylab="")
qqline(Res, distribution=qnorm, lty=2)
# Nuage de points standardisé
plot((Res-m)/s, type="p", main=substitute(bold("Série standardisée")), xlab="", ylab="")
abline(h=c(-1.96, 1.96), lty=2, col="red")
}
checkupRes(rnorm(1000))
X = arima.sim(n = 1000, list(ar = c(0.8897, -0.4858), ma = c(-0.2279, 0.2488)), sd = sqrt(0.1796))
ARMA = Arima(X, order = c(2, 0, 1), include.mean = FALSE)
summary(ARMA)
Res=ARMA$residuals
checkupRes(Res)
# Fonction permettant une analyse visuelle des résidus d'une modélisation par quelques graphiques adaptés
checkupRes = function(Res, l,lagmax=40, lblag=5){
# Partitionnement de la fenêtre graphique
layout(matrix(c(1,1,1,2:7), nrow=3, ncol=3, byrow=TRUE))
par(oma=c(0, 0, 0, 0))
#par(mgp=c(0, 0, 0))
par(mar=c(2.5, 2, 1.5, 2))
m = mean(Res)
s = sd(Res)
# Série des résidus
plot(Res, type="l", col="black", main="Série", xlab="", ylab="", cex=0.6)
# ACF/PACF
ACF = acf(Res, lag.max=lagmax, plot=FALSE)
plot(ACF, ylim=c(-1, 1), xlab="", ylab="")
title("ACF")
PACF = pacf(Res, lag.max=lagmax, plot=FALSE)
plot(PACF, ylim=c(-1, 1), xlab="", ylab="")
title("PACF")
# Nuage de points avec décalage de 1 dans le temps
n = length(Res)
plot(Res[1:(n-1)], Res[2:n], type="p", col="blue", main=substitute(bold("t / t-1")), xlab="", ylab="")
# Test de Ljung-Box
lbpv = Box.test(Res, lag=lblag, type="Ljung-Box")$p.value
cat("Test de Ljung-Box : p-val=", lbpv, sep="")
# Histogramme
hist(Res, breaks=sqrt(n), freq=FALSE, col="skyblue", main="Densité", xlab="", ylab="")
curve(dnorm(x, m=m, sd=s), col="red", lty=2, add=TRUE)
# Test de Shapiro-Wilk
swpv = shapiro.test(Res)$p.value
cat("\nTest de Shapiro : p-val=", swpv, sep="")
# QQ plots
qqnorm(Res, main="Quantiles", xlab="", ylab="")
qqline(Res, distribution=qnorm, lty=2)
# Nuage de points standardisé
plot((Res-m)/s, type="p", main=substitute(bold("Série standardisée")), xlab="", ylab="")
abline(h=c(-1.96, 1.96), lty=2, col="red")
}
checkupRes(rnorm(1000))
# Fonction permettant une analyse visuelle des résidus d'une modélisation par quelques graphiques adaptés
checkupRes = function(Res, l,lagmax=40, lblag=5){
# Partitionnement de la fenêtre graphique
layout(matrix(c(1,1,1,2:7), nrow=3, ncol=3, byrow=TRUE))
par(oma=c(0, 0, 0, 0))
#par(mgp=c(0, 0, 0))
par(mar=c(2.5, 2, 1.5, 2))
m = mean(Res)
s = sd(Res)
# Série des résidus
plot(Res, type="l", col="black", main="Série", xlab="", ylab="", cex=0.6)
# ACF/PACF
ACF = acf(Res, lag.max=lagmax, plot=FALSE)
plot(ACF, ylim=c(-1, 1), xlab="", ylab="")
title("ACF")
PACF = pacf(Res, lag.max=lagmax, plot=FALSE)
plot(PACF, ylim=c(-1, 1), xlab="", ylab="")
title("PACF")
# Nuage de points avec décalage de 1 dans le temps
n = length(Res)
plot(Res[1:(n-1)], Res[2:n], type="p", col="blue", main=substitute(bold("t / t-1")), xlab="", ylab="")
# Test de Ljung-Box
lbpv = Box.test(Res, lag=lblag, type="Ljung-Box")$p.value
cat("Test de Ljung-Box : p-val=", lbpv, sep="")
# Histogramme
hist(Res, breaks=sqrt(n), freq=FALSE, col="skyblue", main="Densité", xlab="", ylab="")
curve(dnorm(x, m=m, sd=s), col="red", lty=2, add=TRUE)
# Test de Shapiro-Wilk
swpv = shapiro.test(Res)$p.value
cat("\nTest de Shapiro : p-val=", swpv, sep="")
# QQ plots
qqnorm(Res, main="Quantiles", xlab="", ylab="")
qqline(Res, distribution=qnorm, lty=2)
# Nuage de points standardisé
plot((Res-m)/s, type="p", main=substitute(bold("Série standardisée")), xlab="", ylab="")
abline(h=c(-1.96, 1.96), lty=2, col="red")
}
checkupRes(rnorm(1000))
# Fonction permettant une analyse visuelle des résidus d'une modélisation par quelques graphiques adaptés
checkupRes = function(Res, l,lagmax=40, lblag=5){
# Partitionnement de la fenêtre graphique
layout(matrix(c(1,1,1,2:7), nrow=3, ncol=3, byrow=TRUE))
par(oma=c(0, 0, 0, 0))
#par(mgp=c(0, 0, 0))
par(mar=c(2.5, 2, 1.5, 2))
m = mean(Res)
s = sd(Res)
# Série des résidus
plot(Res, type="l", col="black", main="Série", xlab="", ylab="", cex=0.6)
# ACF/PACF
ACF = acf(Res, lag.max=lagmax, plot=FALSE)
plot(ACF, ylim=c(-1, 1), xlab="", ylab="")
title("ACF")
PACF = pacf(Res, lag.max=lagmax, plot=FALSE)
plot(PACF, ylim=c(-1, 1), xlab="", ylab="")
title("PACF")
# Nuage de points avec décalage de 1 dans le temps
n = length(Res)
plot(Res[1:(n-1)], Res[2:n], type="p", col="blue", main=substitute(bold("t / t-1")), xlab="", ylab="")
# Test de Ljung-Box
lbpv = Box.test(Res, lag=lblag, type="Ljung-Box")$p.value
cat("Test de Ljung-Box : p-val=", lbpv, sep="")
# Histogramme
hist(Res, breaks=sqrt(n), freq=FALSE, col="skyblue", main="Densité", xlab="", ylab="")
curve(dnorm(x, m=m, sd=s), col="red", lty=2, add=TRUE)
# Test de Shapiro-Wilk
swpv = shapiro.test(Res)$p.value
cat("\nTest de Shapiro : p-val=", swpv, sep="")
# QQ plots
qqnorm(Res, main="Quantiles", xlab="", ylab="")
qqline(Res, distribution=qnorm, lty=2)
# Nuage de points standardisé
plot((Res-m)/s, type="p", main=substitute(bold("Série standardisée")), xlab="", ylab="")
abline(h=c(-1.96, 1.96), lty=2, col="red")
}
checkupRes(rnorm(1000))
# Fonction permettant une analyse visuelle des résidus d'une modélisation par quelques graphiques adaptés
checkupRes = function(Res, l,lagmax=40, lblag=5){
# Partitionnement de la fenêtre graphique
layout(matrix(c(1,1,1,2:7), nrow=3, ncol=3, byrow=TRUE))
par(oma=c(0, 0, 0, 0))
#par(mgp=c(0, 0, 0))
par(mar=c(2.5, 2, 1.5, 2))
m = mean(Res)
s = sd(Res)
# Série des résidus
plot(Res, type="l", col="black", main="Série", xlab="", ylab="", cex=0.6)
# ACF/PACF
ACF = acf(Res, lag.max=lagmax, plot=FALSE)
plot(ACF, ylim=c(-1, 1), xlab="", ylab="")
title("ACF")
PACF = pacf(Res, lag.max=lagmax, plot=FALSE)
plot(PACF, ylim=c(-1, 1), xlab="", ylab="")
title("PACF")
# Nuage de points avec décalage de 1 dans le temps
n = length(Res)
plot(Res[1:(n-1)], Res[2:n], type="p", col="blue", main=substitute(bold("t / t-1")), xlab="", ylab="")
# Test de Ljung-Box
lbpv = Box.test(Res, lag=lblag, type="Ljung-Box")$p.value
cat("Test de Ljung-Box : p-val=", lbpv, sep="")
# Histogramme
hist(Res, breaks=sqrt(n), freq=FALSE, col="skyblue", main="Densité", xlab="", ylab="")
curve(dnorm(x, m=m, sd=s), col="red", lty=2, add=TRUE)
# Test de Shapiro-Wilk
swpv = shapiro.test(Res)$p.value
cat("\nTest de Shapiro : p-val=", swpv, sep="")
# QQ plots
qqnorm(Res, main="Quantiles", xlab="", ylab="")
qqline(Res, distribution=qnorm, lty=2)
# Nuage de points standardisé
plot((Res-m)/s, type="p", main=substitute(bold("Série standardisée")), xlab="", ylab="")
abline(h=c(-1.96, 1.96), lty=2, col="red")
}
checkupRes(rnorm(1000))
checkupRes(rnorm(1000))
file = read.csv("/users/2024/ds2/122003362/Depots/MasterDataScience/Semestre 3/Séries Chronologiques/Datasets/BTC-USD.csv")
data = read.csv("/users/2024/ds2/122003362/Depots/MasterDataScience/Semestre 3/Séries Chronologiques/Datasets/BTC-USD.csv")
class(data)
frequency(data)
plot(data$Date,data$Volume)
data_btc = read.csv("/users/2024/ds2/122003362/Depots/MasterDataScience/Semestre 3/Séries Chronologiques/Datasets/BTC-USD.csv",sep=',')
data_btc = read.csv("/users/2024/ds2/122003362/Depots/MasterDataScience/Semestre 3/Séries Chronologiques/Datasets/BTC-USD.csv",sep=',')
plot(data_btc$Volume ~ data_btc$Date)
class(data_btc$Date)
print(data_btc$Date)
as.Date(data_btc , format = "%Y %b %d")
as.Date(data_btc$Date , format = "%Y %b %d")
as.Date(data_btc$Date , format = "%Y-%b-%d")
as.Date(data_btc$Date , format = "%Y-%m-%d")
data_btc$Date = as.Date(data_btc$Date , format = "%Y-%m-%d")
as.Date(data_btc$Date , format = "%Y-%m-%d")
class(data_btc$Date)
plot(data_btc$Date,data_btc$Close)
plot(data_btc$Date,data_btc$Close,type="l")
dev.off()
data_btc$Date = as.Date(data_btc$Date , format = "%Y-%m-%d")
plot(data_btc$Date,data_btc$Close,type="l")
plot(data_btc$Date,data_btc$Close,type="l",ylab="Close",xlab='Date',main='Action BTC')
plot(data_btc$Date,log(data_btc$Close),type="l",ylab="log(Close)",xlab='Date',main='Action BTC')
log(data_btc)
library(Tseries)
library(tseries)
as.ts(data_btc)
data_btc
log(as.ts(data_btc))
library(forecast)
decompose(log(as.ts(data_btc)),type="additive")
decompose(log(as.ts(data_btc)),type="multiplicative")
plot(data_btc$Date,data_btc$Close,type="l",ylab="Close",xlab='Date',main='Action BTC')
plot(data_btc$Date,log(data_btc$Close),type="l",ylab="log(Close)",xlab='Date',main='Action BTC')
grid()
Arima(log_btc, include.drift=TRUE)
log_btc = log(data_btc$Close)
Arima(log_btc, include.drift=TRUE)
Arima(log_btc,order = c(1,1,1) include.drift=TRUE)
Arima(log_btc,order = c(1,1,1), include.drift=TRUE)
Arima(log_btc,order = c(2,1,1), include.drift=TRUE)
Arima(log_btc,order = c(2,1,2), include.drift=TRUE)
model_arima = Arima(log_btc,order = c(2,1,2), include.drift=TRUE)
model_arima$drift
model_arima$coef
model_arima$coef$drift
model_arima$coef[-1]
model_arima$coef[5]
model_arima = Arima(log_btc,order = c(2,0,2), include.drift=TRUE)
model_arima$coef[5]
model_arima$coef[6]
n=lenght(model_arima$coef)
n=length(model_arima$coef)
model_arima$coef[n]
model_arima = Arima(log_btc, include.drift=TRUE)
n=length(model_arima$coef)
model_arima$coef[n]
k=length(model_arima$coef)
model_arima$coef[k]
n = length(log_btc)
log_btc_sans_tendance = log_btc - log_btc*drift
drift = model_arima$coef[k]
log_btc_sans_tendance = log_btc - log_btc*drift
log_btc_sans_tendance
plot(log_btc_sans_tendance)
plot(log_btc_sans_tendance,type='l')
log_btc = log(data_btc$Close)
plot(log_btc,type='l')
n = length(log_btc)
k = length(model_arima$coef)
model_arima = Arima(log_btc, include.drift=TRUE)
k = length(model_arima$coef)
drift = model_arima$coef[k]
log_btc_sans_tendance = log_btc - log_btc*drift
plot(log_btc_sans_tendance,type='l')
log_btc*drift
log_btc
log_btc*drift
log_btc_sans_tendance = log_btc - log_btc*drift
plot(log_btc_sans_tendance,type='l')
plot(log_btc,type='l')
drift
ARMA = Arima(log_btc, order = c(2, 0, 2), include.drift=TRUE)
summary(ARMA)
Res=ARMA$residuals
Res
plot(REs)
plot(Res)
summary(model_arima)
Res=model_arima$residuals
plot(Res)
Tps = 1:n
RegLin=lm(log_btc~Tps)
lines(fitted(RegLin),col='red',lty=2)
Res = RegLin$Residuals
log_btc = log(data_btc$Close)
plot(log_btc,type='l')
lines(fitted(RegLin),col='red',lty=2)
log_btc = log(data_btc$Close)
plot(log_btc,type='l')
n = length(log_btc)
Tps = 1:n
RegLin=lm(log_btc~Tps)
lines(fitted(RegLin),col='red',lty=2)
Res = RegLin$Residuals
checkupRes = function(Res){
layout(matrix(c(1,1,1,2:7), nrow=3, ncol=3, byrow=TRUE))
######## Graphe 1
plot(Res,type='l',xlab='',ylab=expression(epsilon[t]),main='',col='black')
######## Graphe 2
ACF=acf(Res,lag=50,plot=FALSE)
plot(ACF,ylim=c(-1,1),main='')
######## Graphe 3
PACF=pacf(Res,lag=50,plot=FALSE)
plot(PACF,ylim=c(-1,1),main='',ylab='PACF')
######## Graphe 4
n=length(Res)
plot(Res[1:(n-1)],Res[2:n],type='p',col='purple',ylab=expression(epsilon[t]),xlab=expression(epsilon[t-1]))
######## Graphe 5
moy=mean(Res)
var=var(Res)
hist(Res,main='',col='blue')
"superposer la courbe de la loi normale(oy,var)"
######## Graphe 6
qqPlot(Res)
######## Graphe 7
ResCR = (Res-moy)/var
plot(ResCR[1:(n-1)],ResCR[2:n])
}
checkupRes(Res)
Res
summary(RegLin)
Res = RegLin$residuals
checkupRes(Res)
adf.test(Res)
ARMA = Arima(res,order=c(1,0,0), include.drift=FALSE,include.meand=FALSE)
ARMA = Arima(Res,order=c(1,0,0), include.drift=FALSE,include.meand=FALSE)
ARMA = Arima(Res,order=c(1,0,0), include.drift=FALSE,include.mean=FALSE)
summary(ARMA)
checkupRes(ARMA)
Res = ARMA$residuals
checkupRes(Res)
def.off()
plot(log_btc,type='l')
def.off()
plot(log_btc,type='l')
dev.off()
plot(log_btc,type='l')
lines(fitted(RegLin)+fitted(Res),col='red',lty=2)
lines(fitted(RegLin)+fitted(ARMA),col='red',lty=2)
model_final = fitted(RegLin)+fitted(ARMA)
plot(log_btc,type='l')
lines(model_final,col='red',lty=2)
BS = model_final + 1.96*sqrt(ARMA$sigma2)
model_final = fitted(RegLin)+fitted(ARMA)
plot(log_btc,type='l')
#lines(model_final,col='red',lty=2)
BS = model_final + 1.96*sqrt(ARMA$sigma2) # Borne inf
BI = model_final - 1.96*sqrt(ARMA$sigma2) # Borne sup
lines(BI,col='red',lty=2)
lines(BS,col='blue',lty=2)
model_arima = Arima(log_btc, order = c(1,0,0), include.drift=TRUE)
summary(model_arima)
k = length(model_arima$coef) #le drift c'est le dernier élément
drift = model_arima$coef[k]
plot(drift)
Res=model_arima$residuals
print(drift)
checkupRes(Res)
dev.off()
adf.test(Res) #On ne rejette pas l'hypothèse de non-stationnarité
kpss.test(Res)
exp(log_btc)
plot(exp(log_btc))
plot(exp(log_btc),type='l')
plot(log_btc,type='l')
plot(exp(log_btc),type='l')
plot(log_btc,type='l')
exp(ARMA)
exp(ARMA.fitted.values)
exp(ARMA$fitted.values)
ARMA$fitted
exp(ARMA$fitted)
exp(log_btc)
plot(exp(log_btc),type='l')
exp(model_final)
lines(exp(model_final),col='red',lty=2)
model_final = exp(fitted(RegLin)+fitted(ARMA))
plot(exp(log_btc),type='l')
#lines(model_final,col='red',lty=2)
# Intervalle de confiance :
BS = model_final + 1.96*sqrt(ARMA$sigma2) # Borne inf
BI = model_final - 1.96*sqrt(ARMA$sigma2) # Borne sup
lines(BI,col='red',lty=2)
lines(BS,col='blue',lty=2)
model_final = exp(fitted(RegLin)+fitted(ARMA))
plot(exp(log_btc),type='l')
#lines(model_final,col='red',lty=2)
# Intervalle de confiance :
BS = model_final + 1.96*sqrt(exp(ARMA$sigma2)) # Borne inf
BI = model_final - 1.96*sqrt(exp(ARMA$sigma2)) # Borne sup
lines(BI,col='red',lty=2)
lines(BS,col='blue',lty=2)
model_final = exp(fitted(RegLin)+fitted(ARMA))
plot(exp(log_btc),type='l')
#lines(model_final,col='red',lty=2)
# Intervalle de confiance :
BS = model_final + exp(1.96*sqrt(ARMA$sigma2)) # Borne inf
BI = model_final - exp(1.96*sqrt(ARMA$sigma2)) # Borne sup
lines(BI,col='red',lty=2)
lines(BS,col='blue',lty=2)
model_final = exp(fitted(RegLin)+fitted(ARMA))
plot(exp(log_btc),type='l')
#lines(model_final,col='red',lty=2)
# Intervalle de confiance :
BS =  exp( model_final + 1.96*sqrt(ARMA$sigma2)) # Borne inf
BI =  exp( model_final - 1.96*sqrt(ARMA$sigma2)) # Borne sup
lines(BI,col='red',lty=2)
lines(BS,col='blue',lty=2)
model_final = fitted(RegLin)+fitted(ARMA)
plot(data_btc$Close,type='l')
#lines(model_final,col='red',lty=2)
# Intervalle de confiance :
BS =  exp( model_final + 1.96*sqrt(ARMA$sigma2)) # Borne inf
BI =  exp( model_final - 1.96*sqrt(ARMA$sigma2)) # Borne sup
lines(BI,col='red',lty=2)
lines(BS,col='blue',lty=2)
grid()
plot(data_btc$Close,type='l')
#lines(model_final,col='red',lty=2)
# Intervalle de confiance :
BS =  exp( model_final + 1.96*sqrt(ARMA$sigma2)) # Borne inf
BI =  exp( model_final - 1.96*sqrt(ARMA$sigma2)) # Borne sup
lines(BI,col='red',lty=2)
lines(BS,col='blue',lty=2)
grid()
Rain = scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat", skip=1)
Rain = scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat", skip=1)
Rain
Rain = ts(Rain, start=c(1813))
Rain
view(Rain)
View(Rain)
Rain
Volcano = scan("http://robjhyndman.com/tsdldata/annual/dvi.dat", skip=1)
Volcano = ts(Volcano, start=c(1813))
plot(Rain)
plot(Volcano)
plot(Rain)
plot(log(Rain))
plot(Rain)
plot(log(Rain))
plot(log(Volcano))
Decomp = decompose(Rain, type="additive")
checkupRes = function(Res){
layout(matrix(c(1,1,1,2:7), nrow=3, ncol=3, byrow=TRUE))
######## Graphe 1
plot(Res,type='l',xlab='',ylab=expression(epsilon[t]),main='',col='black')
######## Graphe 2
ACF=acf(Res,lag=50,plot=FALSE)
plot(ACF,ylim=c(-1,1),main='')
######## Graphe 3
PACF=pacf(Res,lag=50,plot=FALSE)
plot(PACF,ylim=c(-1,1),main='',ylab='PACF')
######## Graphe 4
n=length(Res)
plot(Res[1:(n-1)],Res[2:n],type='p',col='purple',ylab=expression(epsilon[t]),xlab=expression(epsilon[t-1]))
######## Graphe 5
moy=mean(Res)
var=var(Res)
hist(Res,main='',col='blue')
"superposer la courbe de la loi normale(oy,var)"
######## Graphe 6
qqPlot(Res)
######## Graphe 7
ResCR = (Res-moy)/var
plot(ResCR[1:(n-1)],ResCR[2:n])
}
model_arima = Arima(log_btc, include.drift=TRUE)
model_arima = Arima(Rain, include.drift=TRUE)
summary(model_arima)
k = length(model_arima$coef)
drift = model_arima$coef[k]
print(drift)
Res=model_arima$residuals
checkupRes(Res)
model_arima = Arima(log(Rain), include.drift=TRUE)
summary(model_arima)
k = length(model_arima$coef)
drift = model_arima$coef[k]
print(drift)
Res=model_arima$residuals
checkupRes(Res)
library(forecasat)
Rain = scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat", skip=1)
Rain = ts(Rain, start=c(1813))
library(forecast)
model_arima = Arima(log(Rain), include.drift=TRUE)
summary(model_arima)
k = length(model_arima$coef)
drift = model_arima$coef[k]
print(drift)
Res=model_arima$residuals
checkupRes(Res)
dev.off()
library(tseries)
adf.test(Res)
kpss.test(Res)
plot(Rain)
plot(Res)
checkupRes(Res)
plot(Volcano)
dev.off()
plot(Volcano)
plot(Volcano)
plot(log(Volcano+1)
)
plot(log(Volcano+1)
)
plot(log(Volcano+1))
plot(Volcano)
ARMA_volcano = Arima(log(Volcano+1), include.drift=TRUE)
summary(ARMA_volcano)
k = length(ARMA_volcano$coef)
drift = ARMA_volcano$coef[k]
print(drift)
Res=ARMA_volcano$residuals
checkupRes(Res)
dev.off()
adf.test(Res)
kpss.test(Res)
plot(log(Volcano+1))
auto.arima(Res,d=0)
ARMA_volcano = Arima(log(Volcano+1),order=c(5,0,1), include.drift=FALSE,include.mean = FALSE)
ARMA_volcano2 = Arima(log(Volcano+1),order=c(5,0,1), include.drift=FALSE,include.mean = FALSE)
ARMA_volcano = Arima(log(Volcano+1), include.drift=TRUE)
summary(ARMA_volcano2)
auto.arima(Res,d=0,ic='bic')
